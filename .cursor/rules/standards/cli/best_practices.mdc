---
description: Defines rules for defining CLI functionality.
alwaysApply: false
---

# CLI Best Practices

- Add all imports at the top of typer commands for the CLI, to avoid expensive imports before the CLI starts.
- Organize CLI groups into module-specific `cli.py` or `cli_{subgroup}.py` files that export a typer app with a collection of sub-commands. Import and attach these groups of commands to the main cli in `src/cli.py`.

# Example Template
```python
# Example root-level src/cli.py
from __future__ import annotations

import typer

# Import groups of commands from sub-modules exported as typer apps.
from src.first_mod.cli import first_mod_app
from src.second_mod.cli import second_mod_app

# Define the root-level app.
app = typer.Typer()


# Attach the sub-commands.
app.add_typer(first_mod_app, name="first_mod")
app.add_typer(second_mod_app, name="second_mod")


# Add root-level commands.
@app.command()
def my_command(
    flag: bool = typer.Option(False, "--flag", help="Flag for some option."),
) -> None:
    """Root level command."""
    # Print statement to provide rapid feedback to the user, before expensive imports.
    print("Starting my command.")

    # Import command-level modules inside the command to avoid expensive imports before executing commands.
    from src.my_mod import my_function_with_expensive_imports

    for i in range(10):
        my_function_with_expensive_imports(toggle_arg=flag)


if __name__ == "__name__":
    app()

```