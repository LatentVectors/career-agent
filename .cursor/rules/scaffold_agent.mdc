---
alwaysApply: false
---
You are responsible for implementing the scaffolding for a new LangGraph agent. This document outlines the steps you must follow to properly scaffold a new agent. You must follow these directions carefully. 

# Workflow

1) **Analyze the Agent's README**
- Review the rules for interpreting an Agent's README file defined in @agent_readme.mdc.
- Carefully examine the Agent's README file and check the following:
    - All required sections are defined.
    - All state entries have a single, consistent type.
    - There are no Node 'Returns' entries that are not used either by another node or in the OutputState.
    - There are no nodes in the Graph that are not defined in the Nodes section.
    - There are no nodes in the Nodes section that are not used anywhere in the Graph.
    - All names are consistent, including state entries, nodes, state types, and edges.
    - All state entry type definitions can be identified in the project.
    - There is nothing unclear, confusing, or contradictory outlined in the Agent's README.
- Notify the user of any problems you identified in your analysis.
- If there are problems or inconsistencies you identified in the Agent's README, DO NOT CONTINUE UNTIL THE USER HAS RESOLVED THE ISSUES OR DIRECTED YOU TO CONTINUE IN THE PROCESS!

2) **Implement the Agent's State**
- If not already created, add the `state.py` file to the agent's module.
- Review the rules for interpreting an Agent's README file defined in @agent_readme.mdc.
- Review the Agent's README file paying special attention to the Agent's State.
- Review the rules for defining an agents state outlined in @agent_state.mdc.
- Using the InputState, OutputState and entries defined in the Nodes 'Returns' sections create the agents `state.py` file and define the InputState, OutputState, InternalState, and PartialInternalState.

3) **Mock-in the Agents's Nodes**
- If not already created, add the `nodes` module to the agent.
- Review the rules for interpreting an Agent's README file defined in @agent_readme.mdc.
- Review the Agent's README file paying special attention to the Agent's Nodes.
- Review the guidelines for interpreting the README's graph section outlined below.
- SINCE YOU ARE ONLY MOCKING IN THE NODE, DO NOT WASTE TIME REVIEWING THE RULES FOR IMPLEMENTING NODES AND JUST FOLLOW THE TEMPLATE OUTLINED IN THIS SECTION!
- Create a file for each node in the `nodes` module using the node's snake_case name for the filename and define the node function in the file using it's snake case name.
- DO NOT IMPLEMENT ANY NODE LOGIC AT THIS POINT! YOUR GOAL IS NOT TO IMPLEMENT A WORKING NODE, IT IS ONLY TO SCAFFOLD THE NODE FUNCTION!
- Use the following template for creating the node function:
    - Replace `my_node_name` with the nodes actual name.
    - Replace `unedited_node_contents_from_agent_readme` with the full, unedited contents of the node's section in the Agent's README, including the summary, Reads, Returns, and any other content defined in that node's section.
```python
from ..state import InputState, PartialInputState

def {my_node_name}(state: InputState) -> PartialInputState:
    """
    {unedited_node_contents_from_agent_readme}
    """
    return PartialInputState()
``` 
- Update `nodes/__init__.py` to import ALL node functions and export them in `__all__`.
```python
from .node_1 import node_1
from .node_2 import node_2

__all__ = (
    "node_1",
    "node_2"
)
```

4) **Implement the Agent's Graph**
- If not already created, add the `graph.py` file to the agent's module.
- Review the rules for interpreting an Agent's README file defined in @agent_readme.mdc.
- Review the Agent's README file paying special attention to the Agent's Graph.
- Review the guidelines for interpreting the README's graph section outlined below.
- Review the rules for defining an agents graph outlined in @agent_graphs.mdc.
- Review the rules for defining an agent's edges outlined in: @agent_edges.mdc
- Import the agents state.
- Import the agents nodes.
- Define the Node StrEnum for the agent's nodes.
- Create the graph builder object.
- Add the nodes to the builder.
- Define any specialized edges, such as map or route edges.
- Add the edges to the builder.
- Compile the graph builder.
- Update the agent modules `__init__.py` to export the compiled agent.
- Update the agent modules `__init__.py` to expose the InputState, OutputState, compiled agent. Alias the compiled graph with a short, descriptive name ending with the `_agent` postfix. See the following template for an example:
```python
from .graph import graph as my_helpful_agent
from .state import InputState, OutputState

__all__ = (
    "my_helpful_agent",
    "InputState",
    "OutputState",
)
```

5) **Review**
- Review the rules for interpreting an Agent's README file defined in @agent_readme.mdc.
- Note: Example names below are illustrative. Replace them with the types, context class, and model names specific to the agent you are scaffolding.
- Perform a full verification pass with the following checklist:
    - State
        - Every entry in Nodes/Edges Reads, Sets, and Returns exists in `InternalState`.
        - `InputState` and `OutputState` match README exactly (names, types, defaults).
        - Iterative/reducer fields (e.g., feedback counters) are clearly named, typed as `int`, and initialized.
        - Map context fields are present in `InternalState`.
        - All referenced types exist in code and are importable (e.g., domain data models and output schemas used by this agent). Replace examples with your agent’s concrete types.
    - Nodes
        - A node file exists for every node listed in the README’s Nodes section.
        - Each node signature is `def node_name(state: InternalState) -> PartialInternalState`.
        - Each node docstring contains the unedited README section for that node.
        - Nodes marked “Defer: True” in README are registered with `defer=True` in the graph.
        - `nodes/__init__.py` imports all node functions and exports them in `__all__`.
    - Graph
        - `Node` StrEnum names match README Graph section exactly.
        - Edges in code mirror README sequence and semantics.
        - Specialized edges are defined with clear names following `{type_prefix}_{edge_name}_edge` (e.g., `map_experience_edge`, `route_feedback_edge`).
        - Map fan-out sets required context fields and sends validated state objects.
        - Graph compiles without errors.
    - Integration
        - Agent package `__init__.py` exports the compiled graph (aliased with `_agent` suffix) and state types.
        - Agent package `__init__.py` exports the `InputState` and `OutputState`.
    - Quality
        - Lint/mypy are clean (or justified) for added/edited files.

- Synchronize the README with the implemented code:
    - Remove any placeholder/sketched type definitions that were moved into code (e.g., inline Pydantic model sketches). Reference the implemented models instead.
    - Ensure naming consistency across Nodes, Graph, State entry names, and types.
    - Ensure there are no orphan nodes (listed but unused) and no Returns that are neither consumed by another node nor included in `OutputState`.
    - Fix obvious grammar/typos for clarity.

- Acceptance Criteria for completion:
    - README and code are fully synchronized; no redundant inline type definitions remain.
    - All nodes are present, wired, and exported; all edges defined and named per convention.
    - State covers all Reads/Returns/Sets with correct types and defaults; graph compiles; lint is clean.
